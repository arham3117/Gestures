<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GestureFlow - Hand Gesture Recognition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #888;
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card h2 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #00d9ff;
        }

        .video-container {
            position: relative;
            width: 100%;
            aspect-ratio: 4/3;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
        }

        #webcam, #preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #preview {
            display: none;
            transform: none;
        }

        /* ROI Guide overlay */
        .roi-guide {
            position: absolute;
            top: 10%;
            right: 5%;
            width: 40%;
            height: 60%;
            border: 3px solid #00ff88;
            border-radius: 8px;
            pointer-events: none;
            z-index: 10;
        }

        .roi-label {
            position: absolute;
            top: 10%;
            right: 5%;
            transform: translateY(-100%);
            background: #00ff88;
            color: #1a1a2e;
            padding: 4px 8px;
            border-radius: 4px 4px 0 0;
            font-size: 0.75rem;
            font-weight: 600;
            z-index: 10;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 120px;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            color: #1a1a2e;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 217, 255, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: #00d9ff;
            background: rgba(0, 217, 255, 0.05);
        }

        .upload-area input {
            display: none;
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .result-card {
            grid-column: 1 / -1;
        }

        .result-display {
            text-align: center;
            padding: 20px;
        }

        .gesture-name {
            font-size: 3rem;
            font-weight: 700;
            margin: 10px 0;
            text-transform: uppercase;
        }

        .confidence {
            font-size: 1.5rem;
            color: #00ff88;
        }

        .low-confidence {
            color: #ff6b6b;
        }

        .all-predictions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        .prediction-bar {
            flex: 1;
            min-width: 150px;
            max-width: 200px;
        }

        .prediction-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .bar-bg {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .status {
            text-align: center;
            padding: 15px;
            color: #888;
        }

        .status.loading {
            color: #00d9ff;
        }

        .status.error {
            color: #ff6b6b;
        }

        .gestures-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .gesture-tag {
            background: rgba(0, 217, 255, 0.2);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .tip-box {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 0.85rem;
        }

        .tip-box strong {
            color: #00ff88;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>GestureFlow</h1>
            <p class="subtitle">Real-time Hand Gesture Recognition powered by CNN</p>
        </header>

        <div class="main-content">
            <!-- Webcam Card -->
            <div class="card">
                <h2>Webcam</h2>
                <div class="video-container">
                    <video id="webcam" autoplay playsinline></video>
                    <canvas id="canvas" style="display: none;"></canvas>
                    <div class="roi-guide" id="roiGuide"></div>
                    <div class="roi-label" id="roiLabel">Place hand here</div>
                </div>
                <div class="controls">
                    <button id="startCam" class="btn-primary">Start Camera</button>
                    <button id="capture" class="btn-secondary" disabled>Capture & Predict</button>
                </div>
                <div class="tip-box">
                    <strong>Tip:</strong> Place your hand inside the green box against a plain background for best results.
                </div>
            </div>

            <!-- Upload Card -->
            <div class="card">
                <h2>Upload Image</h2>
                <div class="upload-area" id="uploadArea">
                    <input type="file" id="fileInput" accept="image/*">
                    <div class="upload-icon">üìÅ</div>
                    <p>Click or drag an image here</p>
                    <p style="color: #666; font-size: 0.85rem; margin-top: 5px;">Supports JPG, PNG, WebP</p>
                </div>
                <div class="video-container hidden" id="previewContainer">
                    <img id="preview" alt="Preview">
                </div>
                <div class="controls">
                    <button id="predictUpload" class="btn-primary hidden">Predict Gesture</button>
                    <button id="clearUpload" class="btn-secondary hidden">Clear</button>
                </div>
                <div class="tip-box">
                    <strong>Tip:</strong> For best results, upload images with just the hand gesture against a plain background.
                </div>
            </div>

            <!-- Result Card -->
            <div class="card result-card">
                <h2>Prediction Result</h2>
                <div id="status" class="status">
                    Upload an image or use webcam to get started
                </div>
                <div id="result" class="result-display hidden">
                    <p>Detected Gesture:</p>
                    <div id="gestureName" class="gesture-name">-</div>
                    <div id="confidenceValue" class="confidence">-</div>
                    <div id="confidenceWarning" class="hidden" style="color: #ff6b6b; font-size: 0.9rem; margin-top: 5px;">
                        Low confidence - try better lighting or positioning
                    </div>
                    <div class="all-predictions" id="allPredictions"></div>
                </div>
            </div>

            <!-- Info Card -->
            <div class="card" style="grid-column: 1 / -1;">
                <h2>Supported Gestures</h2>
                <div class="gestures-list" id="gesturesList">
                    <span class="gesture-tag">Loading...</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = window.location.origin;

        // Elements
        const webcam = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const startCamBtn = document.getElementById('startCam');
        const captureBtn = document.getElementById('capture');
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const preview = document.getElementById('preview');
        const previewContainer = document.getElementById('previewContainer');
        const predictUploadBtn = document.getElementById('predictUpload');
        const clearUploadBtn = document.getElementById('clearUpload');
        const status = document.getElementById('status');
        const result = document.getElementById('result');
        const gestureName = document.getElementById('gestureName');
        const confidenceValue = document.getElementById('confidenceValue');
        const confidenceWarning = document.getElementById('confidenceWarning');
        const allPredictions = document.getElementById('allPredictions');
        const gesturesList = document.getElementById('gesturesList');
        const roiGuide = document.getElementById('roiGuide');
        const roiLabel = document.getElementById('roiLabel');

        let stream = null;
        let uploadedImage = null;

        // Load supported gestures
        async function loadGestures() {
            try {
                const response = await fetch(`${API_BASE}/gestures`);
                const data = await response.json();
                gesturesList.innerHTML = data.gestures
                    .map(g => `<span class="gesture-tag">${g.replace('_', ' ')}</span>`)
                    .join('');
            } catch (error) {
                gesturesList.innerHTML = '<span class="gesture-tag">Error loading</span>';
            }
        }

        // Webcam functions
        async function startCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 640, height: 480 }
                });
                webcam.srcObject = stream;
                startCamBtn.textContent = 'Stop Camera';
                captureBtn.disabled = false;
                roiGuide.style.display = 'block';
                roiLabel.style.display = 'block';
            } catch (error) {
                showStatus('Camera access denied. Please allow camera access.', 'error');
            }
        }

        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                webcam.srcObject = null;
                stream = null;
            }
            startCamBtn.textContent = 'Start Camera';
            captureBtn.disabled = true;
            roiGuide.style.display = 'none';
            roiLabel.style.display = 'none';
        }

        startCamBtn.addEventListener('click', () => {
            if (stream) {
                stopCamera();
            } else {
                startCamera();
            }
        });

        captureBtn.addEventListener('click', async () => {
            const videoWidth = webcam.videoWidth;
            const videoHeight = webcam.videoHeight;

            // Define ROI matching the visual guide (right side of frame, same as training)
            // ROI: x from 50% to 90%, y from 10% to 70%
            const roiX = Math.floor(videoWidth * 0.5);
            const roiY = Math.floor(videoHeight * 0.1);
            const roiWidth = Math.floor(videoWidth * 0.4);
            const roiHeight = Math.floor(videoHeight * 0.6);

            // Set canvas to ROI size
            canvas.width = roiWidth;
            canvas.height = roiHeight;

            const ctx = canvas.getContext('2d');

            // Since video is mirrored (scaleX(-1)), we need to flip when drawing
            // The visual ROI is on the RIGHT of the mirrored video
            // In the actual video data, this corresponds to the LEFT side
            // So we capture from the left side of the actual video frame
            const actualX = videoWidth - roiX - roiWidth;

            ctx.drawImage(webcam, actualX, roiY, roiWidth, roiHeight, 0, 0, roiWidth, roiHeight);

            const imageData = canvas.toDataURL('image/jpeg', 0.9);
            await predict(imageData);
        });

        // Upload functions
        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#00d9ff';
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = 'rgba(255, 255, 255, 0.3)';
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                handleFile(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                handleFile(e.target.files[0]);
            }
        });

        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                uploadedImage = e.target.result;
                preview.src = uploadedImage;
                uploadArea.classList.add('hidden');
                previewContainer.classList.remove('hidden');
                preview.style.display = 'block';
                predictUploadBtn.classList.remove('hidden');
                clearUploadBtn.classList.remove('hidden');
            };
            reader.readAsDataURL(file);
        }

        predictUploadBtn.addEventListener('click', () => {
            if (uploadedImage) {
                predict(uploadedImage);
            }
        });

        clearUploadBtn.addEventListener('click', () => {
            uploadedImage = null;
            preview.src = '';
            preview.style.display = 'none';
            uploadArea.classList.remove('hidden');
            previewContainer.classList.add('hidden');
            predictUploadBtn.classList.add('hidden');
            clearUploadBtn.classList.add('hidden');
            fileInput.value = '';
        });

        // Prediction
        async function predict(imageData) {
            showStatus('Analyzing gesture...', 'loading');
            result.classList.add('hidden');

            try {
                const response = await fetch(`${API_BASE}/predict`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: imageData })
                });

                if (!response.ok) {
                    throw new Error('Prediction failed');
                }

                const data = await response.json();
                showResult(data);
            } catch (error) {
                showStatus('Error: Could not get prediction. Please try again.', 'error');
            }
        }

        function showStatus(message, type = '') {
            status.textContent = message;
            status.className = 'status ' + type;
            status.classList.remove('hidden');
        }

        function showResult(data) {
            status.classList.add('hidden');
            result.classList.remove('hidden');

            gestureName.textContent = data.gesture.replace('_', ' ');
            const confidence = data.confidence * 100;
            confidenceValue.textContent = `${confidence.toFixed(1)}% confidence`;

            // Show warning for low confidence
            if (confidence < 60) {
                confidenceValue.classList.add('low-confidence');
                confidenceWarning.classList.remove('hidden');
            } else {
                confidenceValue.classList.remove('low-confidence');
                confidenceWarning.classList.add('hidden');
            }

            // Show all predictions as bars
            allPredictions.innerHTML = Object.entries(data.all_predictions)
                .sort((a, b) => b[1] - a[1])
                .map(([name, value]) => `
                    <div class="prediction-bar">
                        <div class="prediction-label">
                            <span>${name.replace('_', ' ')}</span>
                            <span>${(value * 100).toFixed(1)}%</span>
                        </div>
                        <div class="bar-bg">
                            <div class="bar-fill" style="width: ${value * 100}%"></div>
                        </div>
                    </div>
                `).join('');
        }

        // Initialize
        loadGestures();

        // Hide ROI guide initially
        roiGuide.style.display = 'none';
        roiLabel.style.display = 'none';
    </script>
</body>
</html>
